---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// Ê£ÄÊü•Áï™ÂâßÈ°µÈù¢ÊòØÂê¶ÂêØÁî®
if (!siteConfig.featurePages.anime) {
	return Astro.redirect("/404/");
}

// Ê£ÄÊü•Áï™ÂâßÈ°µÈù¢ÊòØÂê¶ÂêØÁî®
if (!siteConfig.featurePages.anime) {
	return Astro.redirect("/404/");
}

// Bangumi APIÈÖçÁΩÆ
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id"; // Áî®Êà∑ID
const BANGUMI_API_BASE = "https://api.bgm.tv";

// Ëé∑ÂèñÁï™ÂâßÊï∞ÊçÆÊ®°Âºè(‰∏çÈúÄË¶ÅÊõ¥ÊîπÔºåËØ∑Âú®‰∏ªÈÖçÁΩÆsrc/config.ts‰∏≠‰øÆÊîπ)
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

// ÂâçÁ´ØÂàÜÈ°µÂ§ßÂ∞èÔºàÂêåÊûÑÂà∞ÂÆ¢Êà∑Á´ØËÑöÊú¨Ôºâ
const PAGE_SIZE = 10;

// Ëé∑ÂèñÂçï‰∏™Êù°ÁõÆÁõ∏ÂÖ≥‰∫∫Âëò‰ø°ÊÅØ
async function fetchSubjectPersons(subjectId: number) {
	try {
		const response = await fetch(
			`${BANGUMI_API_BASE}/v0/subjects/${subjectId}/persons`,
		);
		const data = await response.json();
		return Array.isArray(data) ? data : [];
	} catch (error) {
		console.error(`Error fetching subject ${subjectId} persons:`, error);
		return [];
	}
}

// Ëé∑ÂèñBangumiÊî∂ËóèÂàóË°®
async function fetchBangumiCollection(
	userId: string,
	subjectType: number,
	type: number,
) {
	try {
		let allData: any[] = [];
		let offset = 0;
		const limit = 50; // ÊØèÈ°µËé∑ÂèñÁöÑÊï∞Èáè
		let hasMore = true;

		// Âæ™ÁéØËé∑ÂèñÊâÄÊúâÊï∞ÊçÆ
		while (hasMore) {
			const response = await fetch(
				`${BANGUMI_API_BASE}/v0/users/${userId}/collections?subject_type=${subjectType}&type=${type}&limit=${limit}&offset=${offset}`,
			);
			if (!response.ok) {
				throw new Error(`Bangumi API error: ${response.status}`);
			}
			const data = await response.json();

			// Ê∑ªÂä†ÂΩìÂâçÈ°µÊï∞ÊçÆÂà∞ÊÄªÊï∞ÊçÆ‰∏≠
			if (data.data && data.data.length > 0) {
				allData = [...allData, ...data.data];
			}
			if (!data.data || data.data.length < limit) {
				hasMore = false;
			} else {
				offset += limit;
			}
			// Èò≤Ê≠¢ËØ∑Ê±ÇËøá‰∫éÈ¢ëÁπÅ
			await new Promise((resolve) => setTimeout(resolve, 100));
		}
		return { data: allData };
	} catch (error) {
		console.error("Error fetching Bangumi data:", error);
		return null;
	}
}

// Ëé∑ÂèñBangumiÊï∞ÊçÆËΩ¨Êç¢‰∏∫È°µÈù¢ÊâÄÈúÄÊ†ºÂºè
async function processBangumiData(data: any, status: string) {
	if (!data || !data.data) return [];

	// ‰∏∫ÊØè‰∏™Êù°ÁõÆËé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ
	const detailedItems = await Promise.all(
		data.data.map(async (item: any) => {
			// Ëé∑ÂèñÁõ∏ÂÖ≥‰∫∫Âëò‰ø°ÊÅØ
			const subjectPersons = await fetchSubjectPersons(item.subject_id);
			// Ëé∑ÂèñÂπ¥‰ªΩ‰ø°ÊÅØ
			const year = item.subject?.date || "Unknown";
			// Ëé∑ÂèñËØÑÂàÜ
			const rating = item.rate ? Number.parseFloat(item.rate.toFixed(1)) : 0;
			// Ëé∑ÂèñËøõÂ∫¶‰ø°ÊÅØ
			const progress = item.ep_status || 0;
			const totalEpisodes = item.subject?.eps || progress;
			// ‰ªéÁõ∏ÂÖ≥‰∫∫Âëò‰∏≠Ëé∑ÂèñÂà∂‰ΩúÊñπ‰ø°ÊÅØ
			let studio = "Unknown";
			if (Array.isArray(subjectPersons)) {
				// ÂÆö‰πâÁ≠õÈÄâ‰ºòÂÖàÁ∫ßÈ°∫Â∫è
				const priorities = ["Âä®ÁîªÂà∂‰Ωú", "Ë£Ω‰Ωú", "Âà∂‰Ωú"];
				for (const relation of priorities) {
					const match = subjectPersons.find(
						(person) => person.relation === relation,
					);
					if (match?.name) {
						studio = match.name;
						break;
					}
				}
			}

			return {
				title: item.subject?.name_cn || item.subject?.name || "Unknown Title",
				status: status,
				rating: rating,
				cover: item.subject?.images?.medium || "/assets/anime/default.webp",
				description: (
					item.subject?.short_summary ||
					item.subject?.name_cn ||
					""
				).trimStart(),
				episodes: `${totalEpisodes} episodes`,
				year: year,
				genre: item.subject?.tags
					? item.subject.tags.slice(0, 3).map((tag: any) => tag.name)
					: ["Unknown"],
        studio: studio,
        link: item.subject?.id ? `https://bgm.tv/subject/${item.subject.id}` : "#",
        progress: progress,
				totalEpisodes: totalEpisodes,
				startDate: item.subject?.date || "",
				endDate: item.subject?.date || "",
			};
		}),
	);
	return detailedItems;
}

type AnimeItem = (typeof localAnimeList)[number];

const STATUS_ORDER = ["watching", "completed", "planned", "onhold", "dropped"];

function parseDateToTimestamp(dateStr?: string) {
	if (!dateStr) return 0;
	const trimmed = dateStr.trim();
	if (!trimmed) return 0;
	const parsed = Date.parse(trimmed);
	if (!Number.isNaN(parsed)) return parsed;
	const yearMatch = trimmed.match(/^(\d{4})/);
	if (yearMatch) {
		return new Date(Number.parseInt(yearMatch[1], 10), 0, 1).getTime();
	}
	return 0;
}

function sortGroupByDateDesc(list: AnimeItem[]) {
	return [...list].sort((a, b) => {
		const timeA = parseDateToTimestamp(a.startDate || a.year);
		const timeB = parseDateToTimestamp(b.startDate || b.year);
		return timeB - timeA;
	});
}

function sortAnimeListByStatus(animeItems: typeof localAnimeList) {
	const grouped = new Map<string, typeof localAnimeList>();
	for (const anime of animeItems) {
		const status = anime.status || "others";
		if (!grouped.has(status)) {
			grouped.set(status, []);
		}
		grouped.get(status)!.push(anime);
	}

	const ordered: typeof localAnimeList = [];
	for (const status of STATUS_ORDER) {
		if (grouped.has(status)) {
			ordered.push(...sortGroupByDateDesc(grouped.get(status)!));
			grouped.delete(status);
		}
	}

	Array.from(grouped.keys())
		.sort()
		.forEach((status) => {
			ordered.push(...sortGroupByDateDesc(grouped.get(status)!));
		});

	return ordered;
}

// Ê†πÊçÆÊ®°ÂºèËé∑ÂèñÁï™ÂâßÂàóË°®
let animeList: typeof localAnimeList = [];
if (ANIME_MODE === "local") {
	// ‰ΩøÁî®Êú¨Âú∞ÈÖçÁΩÆ
	animeList = sortAnimeListByStatus(localAnimeList);
} else {
	// ‰ΩøÁî®Bangumi APIÔºàÈªòËÆ§Ê®°ÂºèÔºâ
	// Ëé∑Âèñ‰∏éÂ§ÑÁêÜÂú®ÁúãÂàóË°®Ôºàtype=3ÔºâÁúãËøáÂàóË°®Ôºàtype=2Ôºâ
	const watchingData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 3);
	const completedData = await fetchBangumiCollection(BANGUMI_USER_ID, 2, 2);

	const watchingList = watchingData
		? await processBangumiData(watchingData, "watching")
		: [];
	const completedList = completedData
		? await processBangumiData(completedData, "completed")
		: [];

	animeList = sortAnimeListByStatus([...watchingList, ...completedList]);
}

const initialPagination = {
	total: animeList.length,
	totalPages: Math.max(1, Math.ceil(animeList.length / PAGE_SIZE)),
};

// Ëé∑ÂèñÁä∂ÊÄÅÁöÑÁøªËØëÊñáÊú¨ÂíåÊ†∑Âºè
function getStatusInfo(status: string) {
	switch (status) {
		case "watching":
			return {
				text: i18n(I18nKey.animeStatusWatching),
				class:
					"bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
				icon: "‚ñ∂",
			};
		case "completed":
			return {
				text: i18n(I18nKey.animeStatusCompleted),
				class:
					"bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
				icon: "‚úì",
			};
		case "planned":
			return {
				text: i18n(I18nKey.animeStatusPlanned),
				class:
					"bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
				icon: "‚è∞",
			};
		default:
			return {
				text: status,
				class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
				icon: "?",
			};
	}
}

// ËÆ°ÁÆóÁªüËÆ°Êï∞ÊçÆ
const stats = {
	total: animeList.length,
	watching: animeList.filter((anime) => anime.status === "watching").length,
	completed: animeList.filter((anime) => anime.status === "completed").length,
	avgRating: (() => {
		const ratedAnime = animeList.filter((anime) => anime.rating > 0);
		if (ratedAnime.length === 0) return "0.0";
		return (
			ratedAnime.reduce((sum, anime) => sum + anime.rating, 0) /
			ratedAnime.length
		).toFixed(1);
	})(),
};
---

<MainGridLayout title={i18n(I18nKey.anime)} description={i18n(I18nKey.animeSubtitle)}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- È°µÈù¢Ê†áÈ¢ò -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {i18n(I18nKey.animeTitle)}
          </h1>
          <p class="text-black/75 dark:text-white/75">{i18n(I18nKey.animeSubtitle)}</p>
        </div>
        
        <!-- ËøáÊª§ÊåâÈíÆ - ÂèÇËÄÉFireflyËÆæËÆ° -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button class="filter-tag active" data-status="all">{i18n(I18nKey.animeFilterAll)}</button>
            <button class="filter-tag" data-status="watching">{i18n(I18nKey.animeStatusWatching)}</button>
            <button class="filter-tag" data-status="completed">{i18n(I18nKey.animeStatusCompleted)}</button>
            <button class="filter-tag" data-status="planned">{i18n(I18nKey.animeStatusPlanned)}</button>
            {ANIME_MODE === 'bangumi' && (
              <>
                <button class="filter-tag" data-status="onhold">{i18n(I18nKey.animeStatusOnHold)}</button>
                <button class="filter-tag" data-status="dropped">{i18n(I18nKey.animeStatusDropped)}</button>
              </>
            )}
          </div>
        </div>
      </div>

      <!-- Âä®Êº´ÂàóË°® -->
      <div class="mb-8">
        
        {ANIME_MODE !== 'local' && BANGUMI_USER_ID === 'your-user-id' ? (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">üò¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              ËØ∑Âú® src/config.ts Êñá‰ª∂‰∏≠ËÆæÁΩÆ‰Ω†ÁöÑ Bangumi Áî®Êà∑ID
            </p>
          </div>
        ) : animeList.length > 0 ? (
          <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6" data-anime-list data-page-size={PAGE_SIZE}>
            {animeList.map((anime, index) => {
              const statusInfo = getStatusInfo(anime.status);
              const progressPercent = anime.totalEpisodes > 0 ? (anime.progress / anime.totalEpisodes) * 100 : 0;
              const isInitialVisible = index < PAGE_SIZE;
              const cardClasses = [
                "anime-item",
                "group",
                "relative",
                "bg-[var(--card-bg)]",
                "border",
                "border-[var(--line-divider)]",
                "rounded-[var(--radius-large)]",
                "overflow-hidden",
                "transition-all",
                "duration-300",
                "hover:shadow-lg",
                "hover:scale-[1.02]",
                isInitialVisible ? "" : "hidden",
              ].filter(Boolean).join(" ");
              
              return (
                <div class={cardClasses} data-anime-status={anime.status} data-anime-index={index}>
                  <!-- Â∞ÅÈù¢Âå∫Âüü - Á´ñÂ±èÊØî‰æã -->
                  <div class="relative aspect-[2/3] overflow-hidden">
                    <a href={anime.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                      <ImageWrapper 
                        src={anime.cover} 
                        alt={anime.title}
                        class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                      />
                      <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <div class="absolute inset-0 flex items-center justify-center">
                          <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
                            <svg class="w-6 h-6 text-gray-800 ml-1" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M8 5v14l11-7z"/>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </a>
                    
                    <!-- Áä∂ÊÄÅÊ†áÁ≠æ -->
                    <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}>
                      <span class="mr-1">{statusInfo.icon}</span>
                      <span>{statusInfo.text}</span>
                    </div>
                    
                    <!-- ËØÑÂàÜ -->
                    <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
                      <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                      </svg>
                      <span>{anime.rating}</span>
                    </div>
                    
                    <!-- ËøõÂ∫¶Êù° - Âú®Â∞ÅÈù¢Â∫ïÈÉ® -->
                    {anime.status === 'watching' && (
                      <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                        <div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
                          <div class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300" style={`width: ${progressPercent}%`}></div>
                        </div>
                        <div class="text-white text-xs font-medium">
                          {anime.progress}/{anime.totalEpisodes} ({Math.round(progressPercent)}%)
                        </div>
                      </div>
                    )}
                  </div>
                  
                  <!-- ÂÜÖÂÆπÂå∫Âüü - Á¥ßÂáëËÆæËÆ° -->
                  <div class="p-3">
                    <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">{anime.title}</h3>
                    <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">{anime.description}</p>
                    
                    <!-- ËØ¶ÁªÜ‰ø°ÊÅØ - Êõ¥Á¥ßÂáë -->
                    <div class="space-y-1 text-xs">
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeYear)}</span>
                        <span class="text-black/70 dark:text-white/70">{anime.year}</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-black/50 dark:text-white/50">{i18n(I18nKey.animeStudio)}</span>
                        <span class="text-black/70 dark:text-white/70 truncate ml-2">{anime.studio}</span>
                      </div>
                      <div class="flex flex-wrap gap-1 mt-2">
                        {anime.genre.map(g => (
                          <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">{g}</span>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>

          <div class="anime-pagination mt-6" data-pagination-root>
            <button class="pagination-btn" data-pagination="prev" disabled>‰∏ä‰∏ÄÈ°µ</button>
            <div class="pagination-info">
              <span>Á¨¨</span>
              <span data-pagination-current>{initialPagination.total > 0 ? 1 : 0}</span>
              <span>/</span>
              <span data-pagination-total>{initialPagination.totalPages}</span>
              <span>È°µ</span>
            </div>
            <div class="pagination-summary" data-pagination-summary>
              ÂÖ± {initialPagination.total} ÈÉ®
            </div>
            <button class="pagination-btn" data-pagination="next" disabled={initialPagination.totalPages <= 1}>‰∏ã‰∏ÄÈ°µ</button>
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">üò¢</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18n(I18nKey.animeEmpty)}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              {ANIME_MODE === 'local' ? i18n(I18nKey.animeEmptyLocal) : i18n(I18nKey.animeEmptyBangumi)}
            </p>
          </div>
        )}
      </div>
    </div>
  </div>

  <!-- ËøáÊª§ÊåâÈíÆÊ†∑Âºè -->
  <style>
    .filter-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .filter-tag {
      padding: 0.5rem 1rem;
      border: 1px solid var(--line-divider);
      border-radius: var(--radius-large);
      background: var(--btn-regular-bg);
      color: var(--btn-content);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    
    .filter-tag:hover:not(.active) {
      background: var(--btn-hover-bg);
      border-color: var(--primary);
      transform: translateY(-1px);
    }
    
    .filter-tag.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }
    
    .filter-tag.active:hover {
      background: var(--primary) !important;
      color: white !important;
      border-color: var(--primary) !important;
      transform: translateY(-1px);
    }
    
    /* ÈöêËóèÂä®Áîª */
    .anime-item {
      transition: all 0.3s ease;
    }
    
    .anime-item.hidden {
      display: none !important;
      opacity: 0;
      transform: scale(0.95);
      pointer-events: none;
    }

    .anime-pagination {
      margin-top: 1.5rem;
      padding: 0.75rem 1.25rem;
      border: 1px solid var(--line-divider);
      border-radius: var(--radius-large);
      background: var(--btn-regular-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .pagination-btn {
      padding: 0.5rem 1rem;
      border: 1px solid var(--line-divider);
      border-radius: var(--radius-large);
      background: var(--btn-regular-bg);
      color: var(--btn-content);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .pagination-btn:hover:not(:disabled) {
      background: var(--btn-hover-bg);
      border-color: var(--primary);
      transform: translateY(-1px);
    }

    .pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .pagination-info {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-weight: 600;
      color: var(--btn-content);
    }

    .pagination-summary {
      font-size: 0.875rem;
      color: var(--btn-content);
      opacity: 0.8;
    }
  </style>

  <!-- ËøáÊª§‰∏éÂàÜÈ°µËÑöÊú¨ -->
  <script is:inline>
    (() => {
      const DEFAULT_PAGE_SIZE = 10;
      let pageSize = DEFAULT_PAGE_SIZE;
      let filterEventListeners = [];
      let paginationEventListeners = [];
      let animeItems = [];
      const state = {
        status: 'all',
        page: 1,
      };

      function resolvePageSize() {
        const listEl = document.querySelector('[data-anime-list]');
        if (!listEl) return DEFAULT_PAGE_SIZE;
        const attr = listEl.getAttribute('data-page-size');
        const parsed = attr ? Number.parseInt(attr, 10) : Number.NaN;
        if (Number.isNaN(parsed) || parsed <= 0) {
          return DEFAULT_PAGE_SIZE;
        }
        return parsed;
      }

      function cleanupListeners(store) {
        store.forEach(([element, type, handler]) => {
          element.removeEventListener(type, handler);
        });
        return [];
      }

      function selectAnimeItems() {
        animeItems = Array.from(document.querySelectorAll('[data-anime-status]'));
        pageSize = resolvePageSize();
      }

      function getFilteredItems() {
        if (state.status === 'all') return animeItems;
        return animeItems.filter((item) => item.getAttribute('data-anime-status') === state.status);
      }

      function updatePaginationUI(filteredItems) {
        const paginationRoot = document.querySelector('[data-pagination-root]');
        if (!paginationRoot) return;
        const currentEl = paginationRoot.querySelector('[data-pagination-current]');
        const totalEl = paginationRoot.querySelector('[data-pagination-total]');
        const summaryEl = paginationRoot.querySelector('[data-pagination-summary]');
        const prevBtn = paginationRoot.querySelector('[data-pagination="prev"]');
        const nextBtn = paginationRoot.querySelector('[data-pagination="next"]');
        const filteredCount = filteredItems.length;
        const totalPages = filteredCount === 0 ? 1 : Math.ceil(filteredCount / pageSize);
        const displayPage = filteredCount === 0 ? 0 : state.page;
        if (currentEl) currentEl.textContent = String(displayPage);
        if (totalEl) totalEl.textContent = filteredCount === 0 ? '0' : String(totalPages);
        if (summaryEl) summaryEl.textContent = 'ÂÖ± ' + filteredCount + ' ÈÉ®';
        if (prevBtn) prevBtn.disabled = state.page <= 1 || filteredCount === 0;
        if (nextBtn) nextBtn.disabled = state.page >= totalPages || filteredCount === 0;
      }

      function applyVisibility() {
        if (!animeItems.length) return;
        const filteredItems = getFilteredItems();
        const totalPages = filteredItems.length === 0 ? 1 : Math.ceil(filteredItems.length / pageSize);
        if (state.page > totalPages) state.page = totalPages;
        if (state.page < 1) state.page = 1;
        animeItems.forEach((item) => item.classList.add('hidden'));
        const startIndex = (state.page - 1) * pageSize;
        filteredItems.slice(startIndex, startIndex + pageSize).forEach((item) => {
          item.classList.remove('hidden');
        });
        updatePaginationUI(filteredItems);
      }

      function initFilterButtons() {
        const filterTags = document.querySelectorAll('.filter-tag');
        filterEventListeners = cleanupListeners(filterEventListeners);
        filterTags.forEach((tag) => {
          const handler = () => {
            filterTags.forEach((t) => t.classList.remove('active'));
            tag.classList.add('active');
            state.status = tag.getAttribute('data-status') || 'all';
            state.page = 1;
            applyVisibility();
          };
          tag.addEventListener('click', handler);
          filterEventListeners.push([tag, 'click', handler]);
        });
      }

      function initPaginationControls() {
        const paginationRoot = document.querySelector('[data-pagination-root]');
        paginationEventListeners = cleanupListeners(paginationEventListeners);
        if (!paginationRoot) return;
        const prevBtn = paginationRoot.querySelector('[data-pagination="prev"]');
        const nextBtn = paginationRoot.querySelector('[data-pagination="next"]');
        if (prevBtn) {
          const handler = () => {
            if (state.page > 1) {
              state.page -= 1;
              applyVisibility();
            }
          };
          prevBtn.addEventListener('click', handler);
          paginationEventListeners.push([prevBtn, 'click', handler]);
        }
        if (nextBtn) {
          const handler = () => {
            const filteredItems = getFilteredItems();
            const totalPages = filteredItems.length === 0 ? 1 : Math.ceil(filteredItems.length / pageSize);
            if (state.page < totalPages) {
              state.page += 1;
              applyVisibility();
            }
          };
          nextBtn.addEventListener('click', handler);
          paginationEventListeners.push([nextBtn, 'click', handler]);
        }
      }

      function initialize() {
        selectAnimeItems();
        if (!animeItems.length) return;
        state.page = 1;
        initFilterButtons();
        initPaginationControls();
        applyVisibility();
      }

      const kickoff = () => requestAnimationFrame(initialize);
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', kickoff, { once: true });
      } else {
        kickoff();
      }

      let swupListenersInitialized = false;
      function setupSwupListeners() {
        if (swupListenersInitialized || typeof window === 'undefined') return;
        if (!window.swup || !window.swup.hooks) return;
        const reinit = () => setTimeout(kickoff, 150);
        window.swup.hooks.on('content:replace', reinit);
        window.swup.hooks.on('page:view', reinit);
        window.swup.hooks.on('animation:in:end', () => setTimeout(kickoff, 220));
        swupListenersInitialized = true;
      }

      if (typeof window !== 'undefined') {
        if (window.swup && window.swup.hooks) {
          setupSwupListeners();
        } else {
          document.addEventListener('swup:enable', () => {
            setupSwupListeners();
          });
        }
      }
    })();
  </script>

</MainGridLayout>
